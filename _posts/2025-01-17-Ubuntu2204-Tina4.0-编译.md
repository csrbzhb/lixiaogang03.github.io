---
layout:     post
title:      Ubuntu2204 Tina4.0 编译
subtitle:   A133
date:       2025-01-17
author:     LXG
header-img: img/post-bg-phone.jpg
catalog: true
tags:
    - Tina
---

[全志哪吒D1-H Tina Linux Ubuntu 22.04入门踩坑日记](https://blog.csdn.net/zzy602/article/details/128752248)

## 报错-1

```txt

In file included from /usr/include/signal.h:328,
                 from ./signal.h:52,
                 from c-stack.c:49:
c-stack.c:55:26: error: missing binary operator before token "("
   55 | #elif HAVE_LIBSIGSEGV && SIGSTKSZ < 16384
      |                          ^~~~~~~~
make[7]: *** [Makefile:1910: c-stack.o] Error 1

```

**解决方案**

tools/m4/patches/012-fix-sigstksz-ubuntu2204.patch

```diff

--- a/lib/c-stack.c
+++ b/lib/c-stack.c
@@ -50,15 +50,16 @@
 #if ! HAVE_STACK_T && ! defined stack_t
 typedef struct sigaltstack stack_t;
 #endif
-#ifndef SIGSTKSZ
-# define SIGSTKSZ 16384
-#elif HAVE_LIBSIGSEGV && SIGSTKSZ < 16384
-/* libsigsegv 2.6 through 2.8 have a bug where some architectures use
-   more than the Linux default of an 8k alternate stack when deciding
-   if a fault was caused by stack overflow.  */
-# undef SIGSTKSZ
-# define SIGSTKSZ 16384
-#endif
+/* Storage for the alternate signal stack.
+ * 64 KiB is not too large for Gnulib-using apps, and is large enough
+ * for all known platforms. Smaller sizes may run into trouble.
+ * For example, libsigsegv 2.6 through 2.8 have a bug where some
+ * architectures use more than the Linux default of an 8 KiB alternate
+ * stack when deciding if a fault was caused by stack overflow. */
+static max_align_t alternate_signal_stack[(64 * 1024
+					+ sizeof (max_align_t) - 1)
+					/ sizeof (max_align_t)];
+
 
 #include <stdlib.h>
 #include <string.h>
@@ -128,18 +129,6 @@ die (int signo)
 #if (HAVE_SIGALTSTACK && HAVE_DECL_SIGALTSTACK \
      && HAVE_STACK_OVERFLOW_HANDLING) || HAVE_LIBSIGSEGV
 
-/* Storage for the alternate signal stack.  */
-static union
-{
-  char buffer[SIGSTKSZ];
-
-  /* These other members are for proper alignment.  There's no
-     standard way to guarantee stack alignment, but this seems enough
-     in practice.  */
-  long double ld;
-  long l;
-  void *p;
-} alternate_signal_stack;
 
 static void
 null_action (int signo __attribute__ ((unused)))
@@ -205,8 +194,8 @@ c_stack_action (void (*action) (int))
 
   /* Always install the overflow handler.  */
   if (stackoverflow_install_handler (overflow_handler,
-                                     alternate_signal_stack.buffer,
-                                     sizeof alternate_signal_stack.buffer))
+                                     alternate_signal_stack,
+                                     sizeof alternate_signal_stack))
     {
       errno = ENOTSUP;
       return -1;
@@ -279,14 +268,14 @@ c_stack_action (void (*action) (int))
   stack_t st;
   struct sigaction act;
   st.ss_flags = 0;
+  st.ss_sp = alternate_signal_stack;
+  st.ss_size = sizeof alternate_signal_stack;
 # if SIGALTSTACK_SS_REVERSED
   /* Irix mistakenly treats ss_sp as the upper bound, rather than
      lower bound, of the alternate stack.  */
-  st.ss_sp = alternate_signal_stack.buffer + SIGSTKSZ - sizeof (void *);
-  st.ss_size = sizeof alternate_signal_stack.buffer - sizeof (void *);
-# else
-  st.ss_sp = alternate_signal_stack.buffer;
-  st.ss_size = sizeof alternate_signal_stack.buffer;
+  st.ss_size -= sizeof (void *);
+  char *ss_sp = st.ss_sp;
+  st.ss_sp = ss_sp + st.ss_size;
 # endif
   r = sigaltstack (&st, NULL);
   if (r != 0)
--- a/lib/c-stack.h
+++ b/lib/c-stack.h
@@ -34,7 +34,7 @@
    A null ACTION acts like an action that does nothing.
 
    ACTION must be async-signal-safe.  ACTION together with its callees
-   must not require more than SIGSTKSZ bytes of stack space.  Also,
+   must not require more than 64 KiB of stack space.  Also,
    ACTION should not call longjmp, because this implementation does
    not guarantee that it is safe to return to the original stack.
 

```

## 报错-2

```txt

In file included from elf_data.hpp:24,
                 from elf.cpp:21:
elf.hpp:52:56: error: ISO C++17 does not allow dynamic exception specifications
   52 |       const section &get_section(unsigned int i) const throw (std::out_of_range) { return *sections.at(i); };
      |                                                        ^~~~~
elf.hpp:62:47: error: ISO C++17 does not allow dynamic exception specifications
   62 |       static file *open(const char *filename) throw (std::bad_alloc, std::runtime_error);
      |                                               ^~~~~
elf.hpp:65:38: error: ISO C++17 does not allow dynamic exception specifications
   65 |       file(uint8_t *mem, size_t len) throw (std::bad_alloc) : mem(mem), len(len) { }
      |                                      ^~~~~
elf.hpp:68:52: error: ISO C++17 does not allow dynamic exception specifications
   68 |         static file *open_class(uint8_t *, size_t) throw (std::bad_alloc, std::runtime_error);
      |                                                    ^~~~~
elf.hpp:131:55: error: ISO C++17 does not allow dynamic exception specifications
  131 |         std::string get_string(uint32_t offset) const throw (std::bad_alloc)
      |                                                       ^~~~~
elf.hpp:266:39: error: ISO C++17 does not allow dynamic exception specifications
  266 |       std::string get_version() const throw (std::bad_alloc);


```

**解决方案**

tools/mklibs/patches/012-Declare-cxxstd.patch

```diff

--- a/src/mklibs-readelf/Makefile.am
+++ b/src/mklibs-readelf/Makefile.am
@@ -3,1 +3,2 @@ 

+ CXXFLAGS += -std=gnu++98


```












