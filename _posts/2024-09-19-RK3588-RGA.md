---
layout:     post
title:      RK3588 RGA
subtitle:   Raster Graphic Acceleration Unit
date:       2024-09-19
author:     LXG
header-img: img/post-bg-xiaomi.jpg
catalog: true
tags:
    - RK3588
---

[librga-github](https://github.com/airockchip/librga)

[Rockchip_Developer_Guide_RGA_CN-github](https://github.com/airockchip/librga/blob/main/docs/Rockchip_Developer_Guide_RGA_CN.md)

[Rockchip_FAQ_RGA_CN-github](https://github.com/airockchip/librga/blob/main/docs/Rockchip_FAQ_RGA_CN.md)

## 概念

RGA (Raster Graphic Acceleration Unit)是一个独立的2D硬件加速器，可用于加速点/线绘制，执行图像缩放、旋转、bitBlt、alpha混合等常见的2D图形操作。

## 版本

![rk3588_rga_1](/images/rockchip/rk3588_rga_1.png)
![rk3588_rga_2](/images/rockchip/rk3588_rga_2.png)
![rk3588_rga_3](/images/rockchip/rk3588_rga_3.png)

## 支持库librga.so

**查看支持库的版本**

```txt

$ adb shell strings vendor/lib64/librga.so | grep rga_api
rga_api version 1.10.1_[0]

```

**源码**

```txt

hardware/rockchip/librga$ tree -L 1
├── Android.bp
├── Android.go
├── Android.mk
├── buildroot.cmake
├── CHANGELOG.md
├── cmake-android.sh
├── cmake-linux.sh
├── CMakeLists.txt
├── COPYING
├── core
├── cross
├── debian
├── docs
├── im2d_api
├── include
├── meson.build
├── meson_options.txt
├── meson.sh
├── README.md
├── samples
└── version.h.template

```

## 驱动

**源码**

```txt

kernel-5.10/drivers/video/rockchip$ tree  -L 1
├── built-in.a
├── dvbm
├── iep
├── Kconfig
├── Makefile
├── modules.order
├── mpp
├── rga
├── rga2
├── rga3
└── rve

```

**查看驱动版本**

```txt

$ adb shell cat /sys/kernel/debug/rkrga/driver_version
RGA multicore Device Driver: v1.3.3

adb shell cat /proc/rkrga/driver_version

```

## 版本对应关系

使用RGA时需要确认保证当前的运行环境是可以正常工作的，下表为常用的librga与驱动版本对应关系。

| librga版本    | 对应驱动                                                     | 硬件支持         |
| ------------- | ------------------------------------------------------------ | ---------------- |
| 无版本号      | 对应SDK内驱动                                                | RGA1、RGA2       |
| 1.0.0 ~ 1.3.2 | RGA Device Driver（kernel - 4.4及以上）<br/>RGA2 Device Driver（无版本号或v2.1.0） | RGA1、RGA2       |
| > 1.4.0       | RGA multicore Device Driver（v1.2.0及以上）                  | RGA2、RGA3       |
| > 1.9.0       | RGA Device Driver（kernel-4.4及以上）<br/>RGA2 Device Driver（无版本号和v2.1.0）<br/>RGA multicore Device Driver（v1.2.0及以上） | RGA1、RGA2、RGA3 |

## 单独升级RGA驱动后的报错日志

**内核日志**

```txt
[    4.134104] [    T1] rga3 fdb60000.rga: Adding to iommu group 2
[    4.134930] [    T1] rga3 fdb60000.rga: probe successfully, irq = 35, hw_version:3.0.76831
[    4.135103] [    T1] rga3 fdb70000.rga: Adding to iommu group 3
[    4.135531] [    T1] rga3 fdb70000.rga: probe successfully, irq = 36, hw_version:3.0.76831
[    4.136448] [    T1] rga2 fdb80000.rga: probe successfully, irq = 37, hw_version:3.2.63318
[    4.136864] [    T1] rga: Module initialized. v1.3.3

[ 3739.834327] [ T2050] rga_dma_buf: Fail to get dma_buf from fd[111], ret[-9]
[ 3739.834339] [ T2050] rga_mm: rga_mm_map_dma_buffer core[1] map dma buffer error!
[ 3739.834342] [ T2050] rga_mm: rga_mm_map_buffer map dma_buf error!
[ 3739.834345] [ T2050] rga: buffer[0] mm import buffer failed! memory = 0x6f, type = dma_fd(0x0)
[ 3739.856581] [ T2050] rga_dma_buf: Fail to get dma_buf from fd[111], ret[-9]
[ 3739.856595] [ T2050] rga_mm: rga_mm_map_dma_buffer core[1] map dma buffer error!
[ 3739.856598] [ T2050] rga_mm: rga_mm_map_buffer map dma_buf error!
[ 3739.856602] [ T2050] rga: buffer[0] mm import buffer failed! memory = 0x6f, type = dma_fd(0x0)
[ 3739.870378] [ T2050] rga_dma_buf: Fail to get dma_buf from fd[111], ret[-22]
[ 3739.870391] [ T2050] rga_mm: rga_mm_map_dma_buffer core[1] map dma buffer error!
[ 3739.870394] [ T2050] rga_mm: rga_mm_map_buffer map dma_buf error!
[ 3739.870397] [ T2050] rga: buffer[0] mm import buffer failed! memory = 0x6f, type = dma_fd(0x0)
[ 3739.883184] [ T2050] rga_dma_buf: Fail to get dma_buf from fd[111], ret[-22]
[ 3739.883199] [ T2050] rga_mm: rga_mm_map_dma_buffer core[1] map dma buffer error!
[ 3739.883201] [ T2050] rga_mm: rga_mm_map_buffer map dma_buf error!
[ 3739.883204] [ T2050] rga: buffer[0] mm import buffer failed! memory = 0x6f, type = dma_fd(0x0)
[ 3739.894799] [ T2050] rga_dma_buf: Fail to get dma_buf from fd[111], ret[-22]
[ 3739.894813] [ T2050] rga_mm: rga_mm_map_dma_buffer core[1] map dma buffer error!
[ 3739.894817] [ T2050] rga_mm: rga_mm_map_buffer map dma_buf error!
[ 3739.894820] [ T2050] rga: buffer[0] mm import buffer failed! memory = 0x6f, type = dma_fd(0x0)

```

**安卓日志**

```txt

rk3588_s:/ $ logcat --pid 2014

09-19 11:42:48.373  2014  2050 E YOLO_V8_TRACKING_JNI: postprocess release! ret=45500
09-19 11:42:48.373  2014  2050 D YOLO_V8_TRACK_JNI: Elapsed time ---right: 12794251 ns
09-19 11:42:48.375  2014  2050 D YOLO_V8_TRACK_JNI: size of object_size : 3
09-19 11:42:48.378  2014  2050 D RGATestAct: test: {"boxes":[{"cam_id":null,"track_id":1,"x1":328,"x2":395,"y1":116,"y2":198},{"cam_id":null,"track_id":2,"x1":112,"x2":242,"y1":0,"y2":156},{"cam_id":null,"track_id":3,"x1":206,"x2":260,"y1":155,"y2":200}],"camera_id":null,"frame_id":140515360,"frame_ts":0}---23
09-19 11:42:48.391  2014  2050 E YOLO_V8_TRACKING_JNI: postprocess release! ret=37917
09-19 11:42:48.391  2014  2050 D YOLO_V8_TRACK_JNI: Elapsed time ---right: 7180543 ns
09-19 11:42:48.391  2014  2050 D YOLO_V8_TRACK_JNI: size of object_size : 3
09-19 11:42:48.392  2014  2050 D RGATestAct: test: {"boxes":[{"cam_id":null,"track_id":1,"x1":328,"x2":395,"y1":116,"y2":198},{"cam_id":null,"track_id":2,"x1":112,"x2":242,"y1":0,"y2":156},{"cam_id":null,"track_id":3,"x1":206,"x2":260,"y1":155,"y2":200}],"camera_id":null,"frame_id":140515388,"frame_ts":0}---11
09-19 11:42:48.405  2014  2050 E YOLO_V8_TRACKING_JNI: postprocess release! ret=37042
09-19 11:42:48.405  2014  2050 D YOLO_V8_TRACK_JNI: Elapsed time ---right: 7378292 ns
09-19 11:42:48.405  2014  2050 D YOLO_V8_TRACK_JNI: size of object_size : 3
09-19 11:42:48.405  2014  2050 D RGATestAct: test: {"boxes":[{"cam_id":null,"track_id":1,"x1":328,"x2":395,"y1":116,"y2":198},{"cam_id":null,"track_id":2,"x1":112,"x2":242,"y1":0,"y2":156},{"cam_id":null,"track_id":3,"x1":206,"x2":260,"y1":155,"y2":200}],"camera_id":null,"frame_id":140515402,"frame_ts":0}---11
09-19 11:42:48.417  2014  2050 E YOLO_V8_TRACKING_JNI: postprocess release! ret=37041
09-19 11:42:48.418  2014  2050 D YOLO_V8_TRACK_JNI: Elapsed time ---right: 7123667 ns
09-19 11:42:48.418  2014  2050 D YOLO_V8_TRACK_JNI: size of object_size : 3
09-19 11:42:48.418  2014  2050 D RGATestAct: test: {"boxes":[{"cam_id":null,"track_id":1,"x1":328,"x2":395,"y1":116,"y2":198},{"cam_id":null,"track_id":2,"x1":112,"x2":242,"y1":0,"y2":156},{"cam_id":null,"track_id":3,"x1":206,"x2":260,"y1":155,"y2":200}],"camera_id":null,"frame_id":140515415,"frame_ts":0}---11
09-19 11:42:48.430  2014  2050 E YOLO_V8_TRACKING_JNI: postprocess release! ret=37917
09-19 11:42:48.430  2014  2050 D YOLO_V8_TRACK_JNI: Elapsed time ---right: 7956376 ns
09-19 11:42:48.430  2014  2050 D YOLO_V8_TRACK_JNI: size of object_size : 3
09-19 11:42:48.431  2014  2050 D RGATestAct: test: {"boxes":[{"cam_id":null,"track_id":1,"x1":328,"x2":395,"y1":116,"y2":198},{"cam_id":null,"track_id":2,"x1":112,"x2":242,"y1":0,"y2":156},{"cam_id":null,"track_id":3,"x1":206,"x2":260,"y1":155,"y2":200}],"camera_id":null,"frame_id":140515428,"frame_ts":0}---10

```

## 源码跟踪

日志分析

```c

#define EBADF            9      /* Bad file number 错误的文件数量 */
#define EINVAL          22      /* Invalid argument 无效参数 */

```

kernel-5.10/drivers/video/rockchip/rga3/rga_dma_buf.c

```c

int rga_dma_map_fd(int fd, struct rga_dma_buffer *rga_dma_buffer,
		   enum dma_data_direction dir, struct device *rga_dev)
{
	struct dma_buf *dma_buf = NULL;
	struct dma_buf_attachment *attach = NULL;
	struct sg_table *sgt = NULL;
	struct scatterlist *sg = NULL;
	int i, ret = 0;

	dma_buf = dma_buf_get(fd);                     //lixiaogang
	if (IS_ERR(dma_buf)) {
		ret = PTR_ERR(dma_buf);
		pr_err("Fail to get dma_buf from fd[%d], ret[%d]\n", fd, ret);
		return ret;
	}

	attach = dma_buf_attach(dma_buf, rga_dev);
	if (IS_ERR(attach)) {
		ret = PTR_ERR(attach);
		pr_err("Failed to attach dma_buf, ret[%d]\n", ret);
		goto err_get_attach;
	}

	sgt = dma_buf_map_attachment(attach, dir);
	if (IS_ERR(sgt)) {
		ret = PTR_ERR(sgt);
		pr_err("Failed to map attachment, ret[%d]\n", ret);
		goto err_get_sgt;
	}

	rga_dma_buffer->dma_buf = dma_buf;
	rga_dma_buffer->attach = attach;
	rga_dma_buffer->sgt = sgt;
	rga_dma_buffer->iova = sg_dma_address(sgt->sgl);
	rga_dma_buffer->dir = dir;
	rga_dma_buffer->size = 0;
	for_each_sgtable_sg(sgt, sg, i)
		rga_dma_buffer->size += sg_dma_len(sg);

	return ret;

err_get_sgt:
	if (attach)
		dma_buf_detach(dma_buf, attach);
err_get_attach:
	if (dma_buf)
		dma_buf_put(dma_buf);

	return ret;
}

```

kernel-5.10/drivers/dma-buf/dma-buf.c

```c

/**
 * dma_buf_get - returns the dma_buf structure related to an fd
 * @fd:	[in]	fd associated with the dma_buf to be returned
 *
 * On success, returns the dma_buf structure associated with an fd; uses
 * file's refcounting done by fget to increase refcount. returns ERR_PTR
 * otherwise.
 */
struct dma_buf *dma_buf_get(int fd)
{
	struct file *file;

	file = fget(fd);

        // 报错位置: rga_dma_buf: Fail to get dma_buf from fd[111], ret[-9]
	if (!file)
		return ERR_PTR(-EBADF);           // lixiaogang

	if (!is_dma_buf_file(file)) {
		fput(file);
		return ERR_PTR(-EINVAL);
	}

	return file->private_data;
}
EXPORT_SYMBOL_GPL(dma_buf_get);

```

kernel-5.10/drivers/video/rockchip/rga3/rga_mm.c

```c

static int rga_mm_map_dma_buffer(struct rga_external_buffer *external_buffer,
				 struct rga_internal_buffer *internal_buffer,
				 struct rga_job *job)
{
	int ret;
	int ex_buffer_size;
	uint32_t mm_flag = 0;
	phys_addr_t phys_addr = 0;
	struct rga_dma_buffer *buffer;
	struct device *map_dev;
	struct rga_scheduler_t *scheduler;

	scheduler = job ? job->scheduler :
		    rga_drvdata->scheduler[rga_drvdata->map_scheduler_index];
	if (scheduler == NULL) {
		pr_err("Invalid scheduler device!\n");
		return -EINVAL;
	}

	if (external_buffer->memory_parm.size)
		ex_buffer_size = external_buffer->memory_parm.size;
	else
		ex_buffer_size = rga_image_size_cal(external_buffer->memory_parm.width,
						    external_buffer->memory_parm.height,
						    external_buffer->memory_parm.format,
						    NULL, NULL, NULL);
	if (ex_buffer_size <= 0) {
		pr_err("failed to calculating buffer size!\n");
		rga_dump_memory_parm(&external_buffer->memory_parm);
		return ex_buffer_size == 0 ? -EINVAL : ex_buffer_size;
	}

	/*
	 * dma-buf api needs to use default_domain of main dev,
	 * and not IOMMU for devices without iommu_info ptr.
	 */
	map_dev = scheduler->iommu_info ? scheduler->iommu_info->default_dev : scheduler->dev;

	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
	if (buffer == NULL) {
		pr_err("%s alloc internal_buffer error!\n", __func__);
		return  -ENOMEM;
	}

	switch (external_buffer->type) {
	case RGA_DMA_BUFFER:
	        // lixiaogang
		ret = rga_dma_map_fd((int)external_buffer->memory,
				     buffer, DMA_BIDIRECTIONAL,
				     map_dev);
		break;
	case RGA_DMA_BUFFER_PTR:
		ret = rga_dma_map_buf((struct dma_buf *)u64_to_user_ptr(external_buffer->memory),
				      buffer, DMA_BIDIRECTIONAL,
				      map_dev);
		break;
	default:
		ret = -EFAULT;
		break;
	}
	if (ret < 0) {
		pr_err("%s core[%d] map dma buffer error!\n",
		       __func__, scheduler->core);
		goto free_buffer;
	}

	if (buffer->size < ex_buffer_size) {
		pr_err("Only get buffer %ld byte from %s = 0x%lx, but current image required %d byte\n",
		       buffer->size, rga_get_memory_type_str(external_buffer->type),
		       (unsigned long)external_buffer->memory, ex_buffer_size);
		rga_dump_memory_parm(&external_buffer->memory_parm);
		ret = -EINVAL;
		goto unmap_buffer;
	}

	buffer->scheduler = scheduler;

	if (rga_mm_check_range_sgt(buffer->sgt))
		mm_flag |= RGA_MEM_UNDER_4G;

	/*
	 * If it's physically contiguous, then the RGA_MMU can
	 * directly use the physical address.
	 */
	if (rga_mm_check_contiguous_sgt(buffer->sgt)) {
		phys_addr = sg_phys(buffer->sgt->sgl);
		if (phys_addr == 0) {
			pr_err("%s get physical address error!", __func__);
			ret = -EFAULT;
			goto unmap_buffer;
		}

		mm_flag |= RGA_MEM_PHYSICAL_CONTIGUOUS;
	}

	if (!rga_mm_check_memory_limit(scheduler, mm_flag)) {
		pr_err("scheduler core[%d] unsupported mm_flag[0x%x]!\n",
		       scheduler->core, mm_flag);
		ret = -EINVAL;
		goto unmap_buffer;
	}

	internal_buffer->dma_buffer = buffer;
	internal_buffer->mm_flag = mm_flag;
	internal_buffer->phys_addr = phys_addr ? phys_addr : 0;

	return 0;

unmap_buffer:
	rga_dma_unmap_buf(buffer);

free_buffer:
	kfree(buffer);

	return ret;
}


static int rga_mm_map_buffer(struct rga_external_buffer *external_buffer,
			     struct rga_internal_buffer *internal_buffer,
			     struct rga_job *job, int write_flag)
{
	int ret;

	memcpy(&internal_buffer->memory_parm, &external_buffer->memory_parm,
	       sizeof(internal_buffer->memory_parm));

	switch (external_buffer->type) {
	case RGA_DMA_BUFFER:
	case RGA_DMA_BUFFER_PTR:
		internal_buffer->type = external_buffer->type;

		ret = rga_mm_map_dma_buffer(external_buffer, internal_buffer, job);    // lixiaogang
		if (ret < 0) {
			pr_err("%s map dma_buf error!\n", __func__);
			return ret;
		}

		internal_buffer->size = internal_buffer->dma_buffer->size -
					internal_buffer->dma_buffer->offset;
		internal_buffer->mm_flag |= RGA_MEM_NEED_USE_IOMMU;
		break;
	case RGA_VIRTUAL_ADDRESS:
		internal_buffer->type = RGA_VIRTUAL_ADDRESS;

		ret = rga_mm_map_virt_addr(external_buffer, internal_buffer, job, write_flag);
		if (ret < 0) {
			pr_err("%s map virtual address error!\n", __func__);
			return ret;
		}

		internal_buffer->size = internal_buffer->virt_addr->size -
					internal_buffer->virt_addr->offset;
		internal_buffer->mm_flag |= RGA_MEM_NEED_USE_IOMMU;
		break;
	case RGA_PHYSICAL_ADDRESS:
		internal_buffer->type = RGA_PHYSICAL_ADDRESS;

		ret = rga_mm_map_phys_addr(external_buffer, internal_buffer, job);
		if (ret < 0) {
			pr_err("%s map physical address error!\n", __func__);
			return ret;
		}

		internal_buffer->mm_flag |= RGA_MEM_NEED_USE_IOMMU;
		break;
	default:
		pr_err("Illegal external buffer!\n");
		return -EFAULT;
	}

	return 0;
}


/*
 * rga_mm_import_buffer - Importing external buffer into the RGA driver
 *
 * @external_buffer: [in] Parameters of external buffer
 * @session:         [in] Session of the current process
 *
 * returns:
 * if return value > 0, the buffer import is successful and is the generated
 * buffer-handle, negative error code on failure.
 */
int rga_mm_import_buffer(struct rga_external_buffer *external_buffer,
			 struct rga_session *session)
{

	int ret = 0, new_id;
	struct rga_mm *mm;
	struct rga_internal_buffer *internal_buffer;

	mm = rga_drvdata->mm;
	if (mm == NULL) {
		pr_err("rga mm is null!\n");
		return -EFAULT;
	}

	mutex_lock(&mm->lock);

	/* first, Check whether to rga_mm */
	internal_buffer = rga_mm_lookup_external(mm, external_buffer, current->mm);
	if (!IS_ERR_OR_NULL(internal_buffer)) {
		kref_get(&internal_buffer->refcount);

		mutex_unlock(&mm->lock);

		if (DEBUGGER_EN(MM)) {
			pr_info("import existing buffer:\n");
			rga_mm_dump_buffer(internal_buffer);
		}

		return internal_buffer->handle;
	}

	/* finally, map and cached external_buffer in rga_mm */
	internal_buffer = kzalloc(sizeof(struct rga_internal_buffer), GFP_KERNEL);
	if (internal_buffer == NULL) {
		pr_err("%s alloc internal_buffer error!\n", __func__);

		mutex_unlock(&mm->lock);
		return -ENOMEM;
	}

	ret = rga_mm_map_buffer(external_buffer, internal_buffer, NULL, true);    // lixiaogang
	if (ret < 0)
		goto FREE_INTERNAL_BUFFER;

	kref_init(&internal_buffer->refcount);
	internal_buffer->session = session;

	/*
	 * Get the user-visible handle using idr. Preload and perform
	 * allocation under our spinlock.
	 */
	idr_preload(GFP_KERNEL);
	new_id = idr_alloc_cyclic(&mm->memory_idr, internal_buffer, 1, 0, GFP_NOWAIT);
	idr_preload_end();
	if (new_id < 0) {
		pr_err("internal_buffer alloc id failed!\n");
		ret = new_id;
		goto FREE_INTERNAL_BUFFER;
	}

	internal_buffer->handle = new_id;
	mm->buffer_count++;

	if (DEBUGGER_EN(MM)) {
		pr_info("import buffer:\n");
		rga_mm_dump_buffer(internal_buffer);
	}

	mutex_unlock(&mm->lock);
	return internal_buffer->handle;

FREE_INTERNAL_BUFFER:
	mutex_unlock(&mm->lock);
	kfree(internal_buffer);

	return ret;

}


```

kernel-5.10/drivers/video/rockchip/rga3/rga_drv.c

```c

static long rga_ioctl_import_buffer(unsigned long arg, struct rga_session *session)
{
	int i;
	int ret = 0;
	struct rga_buffer_pool buffer_pool;
	struct rga_external_buffer *external_buffer = NULL;

	if (unlikely(copy_from_user(&buffer_pool,
				    (struct rga_buffer_pool *)arg,
				    sizeof(buffer_pool)))) {
		pr_err("rga_buffer_pool copy_from_user failed!\n");
		return -EFAULT;
	}

	if (buffer_pool.size > RGA_BUFFER_POOL_SIZE_MAX) {
		pr_err("Cannot import more than %d buffers at a time!\n",
		       RGA_BUFFER_POOL_SIZE_MAX);
		return -EFBIG;
	}

	if (buffer_pool.buffers_ptr == 0) {
		pr_err("Import buffers is NULL!\n");
		return -EFAULT;
	}

	external_buffer = kmalloc(sizeof(struct rga_external_buffer) * buffer_pool.size,
				  GFP_KERNEL);
	if (external_buffer == NULL) {
		pr_err("external buffer list alloc error!\n");
		return -ENOMEM;
	}

	if (unlikely(copy_from_user(external_buffer,
				    u64_to_user_ptr(buffer_pool.buffers_ptr),
				    sizeof(struct rga_external_buffer) * buffer_pool.size))) {
		pr_err("rga_buffer_pool external_buffer list copy_from_user failed\n");
		ret = -EFAULT;

		goto err_free_external_buffer;
	}

	for (i = 0; i < buffer_pool.size; i++) {
		if (DEBUGGER_EN(MSG)) {
			pr_info("import buffer info:\n");
			rga_dump_external_buffer(&external_buffer[i]);
		}

		ret = rga_mm_import_buffer(&external_buffer[i], session);   //lixiaogang
		if (ret <= 0) {
			pr_err("buffer[%d] mm import buffer failed! memory = 0x%lx, type = %s(0x%x)\n",
			       i, (unsigned long)external_buffer[i].memory,
			       rga_get_memory_type_str(external_buffer[i].type),
			       external_buffer[i].type);

			goto err_free_external_buffer;
		}

		external_buffer[i].handle = ret;
	}

	if (unlikely(copy_to_user(u64_to_user_ptr(buffer_pool.buffers_ptr),
				  external_buffer,
				  sizeof(struct rga_external_buffer) * buffer_pool.size))) {
		pr_err("rga_buffer_pool external_buffer list copy_to_user failed\n");
		ret = -EFAULT;

		goto err_free_external_buffer;
	}

err_free_external_buffer:
	kfree(external_buffer);
	return ret;
}


static long rga_ioctl(struct file *file, uint32_t cmd, unsigned long arg)
{

	int ret = 0;
	int i = 0;
	int major_version = 0, minor_version = 0;
	char version[16] = { 0 };
	struct rga_version_t driver_version;
	struct rga_hw_versions_t hw_versions;
	struct rga_drvdata_t *rga = rga_drvdata;
	struct rga_session *session = file->private_data;

	if (!rga) {
		pr_err("rga_drvdata is null, rga is not init\n");
		return -ENODEV;
	}

	if (DEBUGGER_EN(NONUSE))
		return 0;

	switch (cmd) {
	case RGA_BLIT_SYNC:
	case RGA_BLIT_ASYNC:
		ret = rga_ioctl_blit(arg, cmd, session);

		break;
	case RGA_CACHE_FLUSH:
	case RGA_FLUSH:
	case RGA_GET_RESULT:
		break;
	case RGA_GET_VERSION:
		sscanf(rga->scheduler[i]->version.str, "%x.%x.%*x",
			 &major_version, &minor_version);
		snprintf(version, 5, "%x.%02x", major_version, minor_version);
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
		/* TODO: userspcae to get version */
		if (copy_to_user((void *)arg, version, sizeof(version)))
			ret = -EFAULT;
#else
		if (copy_to_user((void *)arg, RGA3_VERSION,
				 sizeof(RGA3_VERSION)))
			ret = -EFAULT;
#endif
		break;
	case RGA2_GET_VERSION:
		for (i = 0; i < rga->num_of_scheduler; i++) {
			if (rga->scheduler[i]->ops == &rga2_ops) {
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
				if (copy_to_user((void *)arg, rga->scheduler[i]->version.str,
					sizeof(rga->scheduler[i]->version.str)))
					ret = -EFAULT;
#else
				if (copy_to_user((void *)arg, RGA3_VERSION,
						sizeof(RGA3_VERSION)))
					ret = -EFAULT;
#endif
				else
					ret = true;

				break;
			}
		}

		/* This will indicate that the RGA2 version number cannot be obtained. */
		if (ret != true)
			ret = -EFAULT;

		break;

	case RGA_IOC_GET_HW_VERSION:
		/* RGA hardware version */
		hw_versions.size = rga->num_of_scheduler > RGA_HW_SIZE ?
			RGA_HW_SIZE : rga->num_of_scheduler;

		for (i = 0; i < hw_versions.size; i++) {
			memcpy(&hw_versions.version[i], &rga->scheduler[i]->version,
				sizeof(rga->scheduler[i]->version));
		}

		if (copy_to_user((void *)arg, &hw_versions, sizeof(hw_versions)))
			ret = -EFAULT;
		else
			ret = true;

		break;

	case RGA_IOC_GET_DRVIER_VERSION:
		/* Driver version */
		driver_version.major = DRIVER_MAJOR_VERISON;
		driver_version.minor = DRIVER_MINOR_VERSION;
		driver_version.revision = DRIVER_REVISION_VERSION;
		strncpy((char *)driver_version.str, DRIVER_VERSION, sizeof(driver_version.str));

		if (copy_to_user((void *)arg, &driver_version, sizeof(driver_version)))
			ret = -EFAULT;
		else
			ret = true;

		break;

	case RGA_IOC_IMPORT_BUFFER:
		rga_power_enable_all();

		ret = rga_ioctl_import_buffer(arg, session);         // lixiaogang

		rga_power_disable_all();

		break;

	case RGA_IOC_RELEASE_BUFFER:
		rga_power_enable_all();

		ret = rga_ioctl_release_buffer(arg);

		rga_power_disable_all();

		break;

	case RGA_IOC_REQUEST_CREATE:
		ret = rga_ioctl_request_create(arg, session);

		break;

	case RGA_IOC_REQUEST_SUBMIT:
		ret = rga_ioctl_request_submit(arg, true);

		break;

	case RGA_IOC_REQUEST_CONFIG:
		ret = rga_ioctl_request_submit(arg, false);

		break;

	case RGA_IOC_REQUEST_CANCEL:
		ret = rga_ioctl_request_cancel(arg);

		break;

	case RGA_IMPORT_DMA:
	case RGA_RELEASE_DMA:
	default:
		pr_err("unknown ioctl cmd!\n");
		ret = -EINVAL;
		break;
	}

	return ret;
}

#ifdef CONFIG_ROCKCHIP_RGA_DEBUGGER
static int rga_debugger_init(struct rga_debugger **debugger_p)
{
	struct rga_debugger *debugger;

	*debugger_p = kzalloc(sizeof(struct rga_debugger), GFP_KERNEL);
	if (*debugger_p == NULL) {
		pr_err("can not alloc for rga debugger\n");
		return -ENOMEM;
	}

	debugger = *debugger_p;

#ifdef CONFIG_ROCKCHIP_RGA_DEBUG_FS
	mutex_init(&debugger->debugfs_lock);
	INIT_LIST_HEAD(&debugger->debugfs_entry_list);
#endif

#ifdef CONFIG_ROCKCHIP_RGA_PROC_FS
	mutex_init(&debugger->procfs_lock);
	INIT_LIST_HEAD(&debugger->procfs_entry_list);
#endif

	rga_debugfs_init();
	rga_procfs_init();

	return 0;

}

const struct file_operations rga_fops = {
	.owner = THIS_MODULE,
	.open = rga_open,
	.release = rga_release,
	.unlocked_ioctl = rga_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl = rga_ioctl,
#endif
};

```

## librga 跟踪

hardware/rockchip/librga/im2d_api/src/im2d_impl.cpp

```cpp

IM_API IM_STATUS rga_import_buffers(struct rga_buffer_pool *buffer_pool) {
    int ret = 0;

    ret = rga_get_context();
    if (ret != IM_STATUS_SUCCESS)
        return (IM_STATUS)ret;

    if (buffer_pool == NULL) {
        IM_LOGW("buffer pool is null!");
        return IM_STATUS_FAILED;
    }

    ret = ioctl(rgaCtx->rgaFd, RGA_IOC_IMPORT_BUFFER, buffer_pool);
    if (ret < 0) {
        IM_LOGW("RGA_IOC_IMPORT_BUFFER fail! %s", strerror(errno));
        return IM_STATUS_FAILED;
    }

    return IM_STATUS_SUCCESS;
}


IM_API rga_buffer_handle_t rga_import_buffer(uint64_t memory, int type, uint32_t size) {
    struct rga_buffer_pool buffer_pool;
    struct rga_external_buffer buffers[1];

    memset(&buffer_pool, 0x0, sizeof(buffer_pool));
    memset(buffers, 0x0, sizeof(buffers));

    buffers[0].type = type;
    buffers[0].memory = memory;
    buffers[0].memory_info.size = size;

    buffer_pool.buffers = ptr_to_u64(buffers);
    buffer_pool.size = 1;

    if (rga_import_buffers(&buffer_pool) != IM_STATUS_SUCCESS)
        return 0;

    return buffers[0].handle;
}

IM_API rga_buffer_handle_t rga_import_buffer(uint64_t memory, int type, im_handle_param_t *param) {
    int format;
    struct rga_buffer_pool buffer_pool;
    struct rga_external_buffer buffers[1];

    memset(&buffer_pool, 0x0, sizeof(buffer_pool));
    memset(buffers, 0x0, sizeof(buffers));

    buffers[0].type = type;
    buffers[0].memory = memory;
    memcpy(&buffers[0].memory_info, param, sizeof(*param));
    format = convert_to_rga_format(buffers[0].memory_info.format);
    if (format == RK_FORMAT_UNKNOWN) {
        IM_LOGW("Invaild format [0x%x]!\n", buffers[0].memory_info.format);
        return IM_STATUS_NOT_SUPPORTED;
    }
    buffers[0].memory_info.format = format >> 8;

    buffer_pool.buffers = ptr_to_u64(buffers);
    buffer_pool.size = 1;

    if (rga_import_buffers(&buffer_pool) != IM_STATUS_SUCCESS)
        return 0;

    return buffers[0].handle;
}

```











