---
layout:     post
title:      固定串口编号
subtitle:   Linux Android
date:       2023-12-14
author:     LXG
header-img: img/post-bg-android.jpg
catalog: true
tags:
    - android
---

## ttyS3 修改为 ttyS4

longan/kernel/linux-4.9/drivers/tty/tty_io.c

```diff

diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
old mode 100644
new mode 100755
index 33f80b0..3945013
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -1346,11 +1346,17 @@ static void pty_line_name(struct tty_driver *driver, int index, char *p)
  */
 static ssize_t tty_line_name(struct tty_driver *driver, int index, char *p)
 {
+       //int len = -1;
        if (driver->flags & TTY_DRIVER_UNNUMBERED_NODE)
                return sprintf(p, "%s", driver->name);
-       else
-               return sprintf(p, "%s%d", driver->name,
-                              index + driver->name_base);
+       else{
+               if ((index + driver->name_base) == 3)
+                       return sprintf(p, "%s%d", driver->name,
+                                               index + driver->name_base + 6); // ttyS3->ttyS9
+               else
+                       return sprintf(p, "%s%d", driver->name,
+                               index + driver->name_base);
+       }
 }

```

## 串口软链接

symlink /dev/ttyS3 /dev/s3c2410_serial3

## 可插拔 USB 转串口固定编号

**Linux**

在 Linux 系统中，CH341 USB 转串口转换器的设备文件通常被分配为 /dev/ttyUSBx 的形式，其中 x 是一个数字。这个数字表示设备在系统中的顺序，当插入或拔出其他 USB 设备时，它可能会发生变化。

如果你希望固定 CH341 的 ttyUSB 串口号，你可以通过修改 udev 规则来实现这一点。以下是一个简单的步骤：

1. 创建一个新的 udev 规则: 在 /etc/udev/rules.d 目录下创建一个新文件，例如 99-ch341.rules。
2. 编辑规则文件: 使用文本编辑器打开刚才创建的规则文件，并添加以下内容：

```rc

SUBSYSTEM=="tty", ATTRS{idVendor}=="1a86", ATTRS{idProduct}=="7523", SYMLINK+="ch341"

```
这条规则表示所有 vendor ID 为 1a86 和 product ID 为 7523 的设备（这是 CH341 转换器的默认值）都应该被创建一个符号链接，名称为 ch341。

**android**

/kernel/linux-4.9/drivers/usb/serial/usb-serial.c

```c

static int usb_serial_probe(struct usb_interface *interface,
			       const struct usb_device_id *id)
{

        //------------------------------------------------------------------------

	if (allocate_minors(serial, num_ports)) {
		dev_err(ddev, "No more free serial minor numbers\n");
		goto probe_error;
	}

	/* register all of the individual ports with the driver core */
	for (i = 0; i < num_ports; ++i) {
		port = serial->port[i];
		dev_set_name(&port->dev, "ttyUSB%d", port->minor);
		dev_err(ddev, "registering %s\n", dev_name(&port->dev));
		device_enable_async_suspend(&port->dev);

		retval = device_add(&port->dev);
		if (retval)
			dev_err(ddev, "Error registering port device, continuing\n");
	}

	//-------------------------------------------------------------------------

}

static int allocate_minors(struct usb_serial *serial, int num_ports)
{
	struct usb_serial_port *port;
	unsigned int i, j;
	int minor;

	dev_dbg(&serial->interface->dev, "%s %d\n", __func__, num_ports);

	mutex_lock(&table_lock);
	for (i = 0; i < num_ports; ++i) {
		port = serial->port[i];
		minor = idr_alloc(&serial_minors, port, 0,
					USB_SERIAL_TTY_MINORS, GFP_KERNEL);
		if (minor < 0)
			goto error;
		port->minor = minor;
		port->port_number = i;
	}
	serial->minors_reserved = 1;
	mutex_unlock(&table_lock);
	return 0;
error:
	/* unwind the already allocated minors */
	for (j = 0; j < i; ++j)
		idr_remove(&serial_minors, serial->port[j]->minor);
	mutex_unlock(&table_lock);
	return minor;
}

```




















