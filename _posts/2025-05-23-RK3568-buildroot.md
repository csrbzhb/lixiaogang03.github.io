---
layout:     post
title:      RK3568 Buildroot
subtitle:   linux
date:       2025-05-23
author:     LXG
header-img: img/post-bg-xiaomi.jpg
catalog: true
tags:
    - linux
---

Rockchip_Developer_Guide_Linux_Software_CN.pdf

Rockchip_Developer_Guide_Buildroot_CN.pdf

## buildroot 添加 ffmpeg

```diff

diff --git a/buildroot/configs/rockchip/multimedia/ffmpeg.config b/buildroot/configs/rockchip/multimedia/ffmpeg.config
new file mode 100644
index 000000000..34eadb644
--- /dev/null
+++ b/buildroot/configs/rockchip/multimedia/ffmpeg.config
@@ -0,0 +1,2 @@
+BR2_PACKAGE_FFMPEG=y
+BR2_PACKAGE_FFMPEG_SWSCALE=y
diff --git a/buildroot/configs/rockchip_rk3568_defconfig b/buildroot/configs/rockchip_rk3568_defconfig
index 0637322b6..4e44f2449 100644
--- a/buildroot/configs/rockchip_rk3568_defconfig
+++ b/buildroot/configs/rockchip_rk3568_defconfig
@@ -6,6 +6,7 @@
 #include "fs/vfat.config"
 #include "gpu/gpu.config"
 #include "multimedia/audio.config"
+#include "multimedia/ffmpeg.config"
 #include "multimedia/camera.config"
 #include "multimedia/gst/audio.config"
 #include "multimedia/gst/camera.config"

```

**编译**

./build.sh buildroot

## USB Gadget

Rockchip_Quick_Start_Linux_USB_Gadget_CN.pdf

Rockchip_Trouble_Shooting_Linux4.19_USB_Gadget_UVC_CN.pdf

**kernel/arch/arm64/configs/rockchip_linux_defconfig**

```sh

CONFIG_USB_GADGET=y
CONFIG_USB_GADGET_DEBUG_FILES=y
CONFIG_USB_GADGET_VBUS_DRAW=500
CONFIG_USB_CONFIGFS=y
CONFIG_USB_CONFIGFS_UEVENT=y
CONFIG_USB_CONFIGFS_ACM=y
CONFIG_USB_CONFIGFS_RNDIS=y
CONFIG_USB_CONFIGFS_MASS_STORAGE=y
CONFIG_USB_CONFIGFS_F_FS=y
CONFIG_USB_CONFIGFS_F_UAC1=y
CONFIG_USB_CONFIGFS_F_UAC1_LEGACY=y
CONFIG_USB_CONFIGFS_F_UAC2=y
CONFIG_USB_CONFIGFS_F_MIDI=y
CONFIG_USB_CONFIGFS_F_HID=y
CONFIG_USB_CONFIGFS_F_UVC=y


```

**RKScript中，有三个USB相关文件：**

```sh

S50usbdevice # /etc/init.d/ 使用时，配合同级目录的.usb_config使用
usbdevice # /usr/bin/
61-usbdevice.rules # /lib/udev/rules.d/

#还有两个相关文件需要用户自建或修改
.usb_config # /etc/init.d/
/tmp/.usb_config # S50usbdevice 自动生成

```

**./buildroot/output/rockchip_rk3568/target/etc/init.d/S50usbdevice.sh**

```sh

#!/bin/sh
### BEGIN INIT INFO
# Provides:       usbdevice
# Required-Start: $local_fs $syslog
# Required-Stop:  $local_fs
# Default-Start:  S
# Default-Stop:   K
# Description:    Manage USB device functions
### END INIT INFO

case "$1" in
	start|stop|restart)
		/sbin/start-stop-daemon -Sbx /usr/bin/usbdevice $1
		;;
	*)
		echo "Usage: [start|stop|restart]" >&2
		exit 3
		;;
esac

:

```

**.usb_config 支持的配置项**


```sh

#!/bin/sh

# 启用 ADB 调试功能
usb_adb_en=1

# 启用 USB 音频类 1.0（兼容性好）
usb_uac1_en=0

# 启用 USB 音频类 2.0（高质量音频）
usb_uac2_en=1

# 启用 USB 网络共享功能（RNDIS 协议）
usb_rndis_en=1

# 启用 MTP 模式（媒体文件传输）
usb_mtp_en=1

# 启用 USB 大容量存储（UMS，如 U 盘模式）
usb_ums_en=0

# 启用 USB 串口通信（ACM）
usb_acm_en=1

# 启用 USB 视频类（UVC，支持摄像头）
usb_uvc_en=1

```


## 配置USB Gadget UVC

```diff

diff --git a/buildroot/board/rockchip/rk3566_rk3568/fs-overlay/etc/init.d/.usb_config b/buildroot/board/rockchip/rk3566_rk3568/fs-overlay/etc/init.d/.usb_config
index 3de3a0bb7..a41345923 100644
--- a/buildroot/board/rockchip/rk3566_rk3568/fs-overlay/etc/init.d/.usb_config
+++ b/buildroot/board/rockchip/rk3566_rk3568/fs-overlay/etc/init.d/.usb_config
@@ -1 +1 @@
-usb_adb_en
+usb_uvc_en
diff --git a/external/rkscript/S50usbdevice.sh b/external/rkscript/S50usbdevice.sh
index 9679d40b9..282d49cdc 100755
--- a/external/rkscript/S50usbdevice.sh
+++ b/external/rkscript/S50usbdevice.sh
@@ -10,7 +10,9 @@
 
 case "$1" in
        start|stop|restart)
+               /usr/bin/uvc_config.sh
                /sbin/start-stop-daemon -Sbx /usr/bin/usbdevice $1
+               /sbin/start-stop-daemon --start --quiet --background --exec /usr/bin/uvc_app -- 640 480
                ;;
        *)
                echo "Usage: [start|stop|restart]" >&2


```

**上述修改配置好后 RK3568 USB 插入后的日志**

```bash

[   20.486987] dwc3 fcc00000.dwc3: device reset
[   20.668248] dwc3 fcc00000.dwc3: device reset
[   20.865929] android_work: sent uevent USB_STATE=CONNECTED
[   20.899630] configfs-gadget gadget: uvc: uvc_function_set_alt(0, 0)
[   20.899709] configfs-gadget gadget: uvc: reset UVC Control
[   20.899750] configfs-gadget gadget: uvc: uvc_function_set_alt(1, 0)
[   20.899938] android_work: sent uevent USB_STATE=CONFIGURED

```

**ubuntu lsusb命令显示的 usb 设备(未被识别成UVC摄像头)**

```bash

Bus 001 Device 017: ID 2207:0005 Fuzhou Rockchip Electronics Company rk3xxx

```

**android端日志**

```bash

[  128.409060] usb 7-1: new high-speed USB device number 4 using xhci-hcd
[  128.551376] usb 7-1: New USB device found, idVendor=2207, idProduct=0005, bcdDevice= 3.10
[  128.551457] usb 7-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[  128.551485] usb 7-1: Product: UVC
[  128.551508] usb 7-1: Manufacturer: Rockchip
[  128.551529] usb 7-1: SerialNumber: 2020
[  128.638262] input: UVC: UVC Camera as /devices/platform/usbdrd/fcc00000.dwc3/xhci-hcd.6.auto/usb7/7-1/7-1:1.0/input/input8

```

## external/rkscript/usbdevice

```sh

#!/bin/sh
#
# Usage:
# usbdevice [start|update|stop]
#
# Hookable stages:
# usb_<pre|post>_<init|prepare|start|stop|restart>_hook
# <usb function>_<pre|post>_<prepare|start|stop>_hook
#
# Example hook:
# root@RK3588:/# more /etc/usbdevice.d/usb_init.sh
# #!/bin/sh
# usb_pre_init_hook()
# {
#	echo "usb pre-init hook"
# }
#
# root@RK3588:/# more /etc/usbdevice.d/uvc.sh
# #!/bin/sh
# UVC_INSTANCES="uvc.gs1 uvc.gs2"

[ -z "$DEBUG" ] || set -x

# Load default env variables from profiles
. /etc/profile

# Enable error out after loading env
set -e

TAG_DIR=/var/run/
LOG_FILE=/var/log/usbdevice.log
USB_FUNCS_FILE=/var/run/.usbdevice

alias usb_enable='touch $USB_FUNCS_FILE'
alias usb_disable='rm -f $USB_FUNCS_FILE'
alias usb_is_enabled='[ -f $USB_FUNCS_FILE ]'
alias usb_set_started='echo $USB_FUNCS > $USB_FUNCS_FILE'
usb_get_started()
{
	usb_is_enabled || return 0
	cat $USB_FUNCS_FILE
}

CONFIGFS_DIR=/sys/kernel/config
USB_GROUP=rockchip
USB_STRINGS_ATTR=strings/0x409
USB_GADGET_DIR=$CONFIGFS_DIR/usb_gadget/$USB_GROUP
USB_GADGET_STRINGS_DIR=$USB_GADGET_DIR/$USB_STRINGS_ATTR
USB_FUNCTIONS_DIR=$USB_GADGET_DIR/functions
USB_CONFIGS_DIR=$USB_GADGET_DIR/configs/b.1
USB_CONFIGS_STRINGS_DIR=$USB_CONFIGS_DIR/$USB_STRINGS_ATTR

# Make sure that we own this session (pid equals sid)
if [ $(sed "s/(.*)//" /proc/$$/stat | cut -d' ' -f6) != $$ ]; then
	setsid $0 $@
	exit $?
fi

# ---- helper functions
usb_msg()
{
	logger -t "$(basename "$0")" "[$$]: $@"
	echo "[$(date +"%F %T")] $@"
}

usb_pid()
{
	case "$(echo $USB_FUNCS | xargs -n 1 | sort | xargs | tr ' ' '-')" in
		ums)		echo 0x0000;;
		mtp)		echo 0x0001;;
		uvc)		echo 0x0005;;
		adb)		echo 0x0006;;
		adb-mtp)	echo 0x0011;;
		adb-ums)	echo 0x0018;;
		adb-uvc)	echo 0x0015;;
		ntb-uvc)	echo 0x0017;;
		acm)		echo 0x1005;;
		*)		echo 0x0019;;
	esac
}

usb_instances()
{
	for func in $@; do
		VAR=$(echo $func | tr 'a-z' 'A-Z')_INSTANCES
		eval echo "\${$VAR:-$func.gs0}"
	done
}

usb_run_stage()
{
	for f in $1_pre_$2_hook $1_$2 $1_post_$2_hook; do
		type $f >/dev/null 2>/dev/null || continue

		usb_msg "Run stage: $f"
		eval $f || break
	done
}

usb_wait_files()
{
	for i in `seq 200`;do
		fuser -s $@ 2>/dev/null && break
		sleep .01
	done
}

usb_release_files()
{
	for i in `seq 200`;do
		fuser -s -k $@ 2>/dev/null || break
		sleep .01
	done
}

# usage: usb_mount <src> <mountpoint> <options>
usb_mount()
{
	mkdir -p $2
	mountpoint -q $2 || mount $@
}

usb_umount()
{
	mountpoint -q $1 || return 0
	usb_release_files -m $1
	umount $1
}

usb_symlink()
{
	mkdir -p $1
	[ -e $2 ] || ln -s $1 $2
}

usb_try_symlink()
{
	usb_symlink $@ >/dev/null 2>/dev/null || true
}

usb_write()
{
	if echo "x$1" | grep -q "^x-"; then
		OPTS="$1"
		shift
	fi

	FILE="$1"
	shift

	if [ ! -w "$FILE" ]; then
		echo "$FILE not writable!"
		return 1
	fi

	if [ -r "$FILE" ] && [ "$(cat "$FILE")" = "$*" ]; then
		return 0
	fi

	echo $OPTS $@ > "$FILE"
}

usb_try_write()
{
	usb_write $@ >/dev/null 2>/dev/null || true
}

usb_start_daemon()
{
	NAME=$(echo $1 | sed "s~^[^ ]*/\([^ ]*\).*~\1~")
	TAG_FILE=$TAG_DIR.usb_$NAME

	# Enable spawn
	touch $TAG_FILE

	# Already started
	[ -z "$(usb_get_started)" ] || return 0

	# Start and spawn background daemon
	{
		exec 3<&-

		cd /
		while usb_is_enabled; do
			# Don't spawn after stopped
			[ ! -f $TAG_FILE ] ||
				/sbin/start-stop-daemon -Sqx $@ || true
			sleep .5
		done
	}&
}

usb_stop_daemon()
{
	NAME=$(echo $1 | sed "s~^[^ ]*/\([^ ]*\).*~\1~")
	TAG_FILE=$TAG_DIR.usb_$NAME

	# Stop and disable spawn
	rm -f $TAG_FILE
	/sbin/start-stop-daemon -Kqox $@
}

usb_load_config()
{
	USB_CONFIG_FILE=$(find /tmp/ /etc/ -name .usb_config | head -n 1)
	[ -n "$USB_CONFIG_FILE" -a -r "$USB_CONFIG_FILE" ] || return 0

	ums_parse()
	{
		grep "\<$1=" "$USB_CONFIG_FILE" | cut -d'=' -f2
	}
	UMS_FILE="$(ums_parse ums_block)"
	UMS_SIZE=$(ums_parse ums_block_size || echo 0)M
	UMS_FSTYPE=$(ums_parse ums_block_type)
	UMS_MOUNT=$([ "$(ums_parse ums_block_auto_mount)" != on ] || echo 1)
	UMS_RO=$([ "$(ums_parse ums_block_ro)" != on ] || echo 1)

	USB_FUNCS="$(sed -n "s/usb_\(.*\)_en/\1/p" "$USB_CONFIG_FILE" | xargs)"
}

# ---- adb
ADB_INSTANCES=${ADB_INSTANCES:-ffs.adb}

adb_prepare()
{
	usb_mount adb /dev/usb-ffs/adb -o uid=2000,gid=2000 -t functionfs
	usb_start_daemon /usr/bin/adbd
	usb_wait_files -m /dev/usb-ffs/adb
}

adb_stop()
{
	usb_stop_daemon /usr/bin/adbd
}

# ---- ntb
NTB_INSTANCES=${NTB_INSTANCES:-ffs.ntb}

ntb_prepare()
{
	usb_mount ntb /dev/usb-ffs/ntb -o uid=2000,gid=2000 -t functionfs
}

# ---- uac1
uac1_prepare()
{
	for f in $(find . -name "*_feature_unit"); do
		echo 1 >$f
	done
}

# ---- uac2
uac2_prepare()
{
	uac1_prepare
}

# ---- mtp
mtp_prepare()
{
	echo "MTP" > os_desc/interface.MTP/compatible_id
	echo 1 > $USB_GADGET_DIR/os_desc/use
}

mtp_start()
{
	usb_start_daemon /usr/bin/mtp-server
	usb_wait_files /dev/mtp_usb
}

mtp_stop()
{
	usb_stop_daemon /usr/bin/mtp-server
	usb_release_files /dev/mtp_usb

	echo 0 > $USB_GADGET_DIR/os_desc/use
}

# ---- acm
ACM_INSTANCES=${ACM_INSTANCES:-acm.gs6}

# ---- rndis
# Nothing special

# ---- uvc
UVC_INSTANCES=${UVC_INSTANCES:-uvc.gs6}

uvc_add_yuyv()
{
	WIDTH=$(echo $1 | cut -d'x' -f1)
	HEIGHT=$(echo $1 | cut -d'x' -f2)
	DIR=${HEIGHT}p

	[ ! -d $DIR ] || return 0

	mkdir -p $DIR
	echo $WIDTH > $DIR/wWidth
	echo $HEIGHT > $DIR/wHeight
	echo 333333 > $DIR/dwDefaultFrameInterval
	echo $((WIDTH * HEIGHT * 20)) > $DIR/dwMinBitRate
	echo $((WIDTH * HEIGHT * 20)) > $DIR/dwMaxBitRate
	echo $((WIDTH * HEIGHT * 2)) > $DIR/dwMaxVideoFrameBufferSize
	echo -e "333333\n666666\n1000000\n2000000" > $DIR/dwFrameInterval
}

uvc_add_mjpeg()
{
	WIDTH=$(echo $1 | cut -d'x' -f1)
	HEIGHT=$(echo $1 | cut -d'x' -f2)
	DIR=${HEIGHT}p

	[ ! -d $DIR ] || return 0

	mkdir -p $DIR
	echo $WIDTH > $DIR/wWidth
	echo $HEIGHT > $DIR/wHeight
	echo 333333 > $DIR/dwDefaultFrameInterval
	echo $((WIDTH * HEIGHT * 20)) > $DIR/dwMinBitRate
	echo $((WIDTH * HEIGHT * 20)) > $DIR/dwMaxBitRate
	echo $((WIDTH * HEIGHT * 2)) > $DIR/dwMaxVideoFrameBufferSize
	echo -e "333333\n666666\n1000000\n2000000" > $DIR/dwFrameInterval
}

uvc_add_h264()
{
	WIDTH=$(echo $1 | cut -d'x' -f1)
	HEIGHT=$(echo $1 | cut -d'x' -f2)
	DIR=${HEIGHT}p

	[ ! -d $DIR ] || return 0

	mkdir -p $DIR
	echo $WIDTH > $DIR/wWidth
	echo $HEIGHT > $DIR/wHeight
	echo 333333 > $DIR/dwDefaultFrameInterval
	echo $((WIDTH * HEIGHT * 10)) > $DIR/dwMinBitRate
	echo $((WIDTH * HEIGHT * 10)) > $DIR/dwMaxBitRate
	echo -e "333333\n666666\n1000000\n2000000" > $DIR/dwFrameInterval
}

uvc_support_resolutions()
{
	case ${1:-yuyv} in
		yuyv)	echo "640x480 1280x720";;
		mjpeg)	echo "640x480 1280x720 1920x1080 2560x1440 2592x1944";;
		h264)	echo "640x480 1280x720 1920x1080";;
	esac
}

uvc_prepare()
{
	UVC_DIR=$(pwd)

	usb_symlink $UVC_DIR/control/header/h $UVC_DIR/control/class/fs/h
	usb_symlink $UVC_DIR/control/header/h $UVC_DIR/control/class/ss/h

	usb_symlink $UVC_DIR/streaming/header/h $UVC_DIR/streaming/class/fs/h
	usb_symlink $UVC_DIR/streaming/header/h $UVC_DIR/streaming/class/hs/h
	usb_symlink $UVC_DIR/streaming/header/h $UVC_DIR/streaming/class/ss/h

	UVC_YUYV_RES=$(uvc_support_resolutions yuyv)
	if [ -n "$UVC_YUYV_RES" ]; then
		usb_try_symlink $UVC_DIR/streaming/uncompressed/u \
			$UVC_DIR/streaming/header/h/u
		cd $UVC_DIR/streaming/uncompressed/u

		for res in $UVC_YUYV_RES; do
			uvc_add_yuyv $res
		done
	fi

	UVC_MJPEG_RES=$(uvc_support_resolutions mjpeg)
	if [ -n "$UVC_MJPEG_RES" ]; then
		usb_try_symlink $UVC_DIR/streaming/mjpeg/m \
			$UVC_DIR/streaming/header/h/m
		cd $UVC_DIR/streaming/mjpeg/m

		for res in $UVC_MJPEG_RES; do
			uvc_add_mjpeg $res
		done
	fi

	UVC_H264_RES=$(uvc_support_resolutions h264)
	if [ -n "$UVC_H264_RES" ]; then
		usb_try_symlink $UVC_DIR/streaming/framebased/f \
			$UVC_DIR/streaming/header/h/f
		cd $UVC_DIR/streaming/framebased/f

		for res in $UVC_H264_RES; do
			uvc_add_h264 $res
		done

		usb_try_write -ne guidFormat "\\x48\\x32\\x36\\x34\\x00\\x00\\x10\\x00\\x80\\x00\\x00\\xaa\\x00\\x38\\x9b\\x71"
	fi
}

# TODO: Start UVC daemon in uvc_start
# TODO: Stop UVC daemon in uvc_stop

# ---- hid
HID_INSTANCES=${HID_INSTANCES:-hid.usb0}

hid_prepare()
{
	echo 1 > protocol
	echo 1 > subclass
	echo 8 > report_length
	echo -ne "\\x05\\x01\\x09\\x06\\xa1\\x01\\x05\\x07\\x19\\xe0\\x29\\xe7\\x15\\x00\\x25\\x01\\x75\\x01\\x95\\x08\\x81\\x02\\x95\\x01\\x75\\x08\\x81\\x03\\x95\\x05\\x75\\x01\\x05\\x08\\x19\\x01\\x29\\x05\\x91\\x02\\x95\\x01\\x75\\x03\\x91\\x03\\x95\\x06\\x75\\x08\\x15\\x00\\x25\\x65\\x05\\x07\\x19\\x00\\x29\\x65\\x81\\x00\\xc0" \
		> report_desc
}

# ---- ums
UMS_INSTANCES=${UMS_INSTANCES:-mass_storage.0}

ums_prepare()
{
	if [ ! -f "$UMS_FILE" ]; then
		usb_msg "Formating $UMS_FILE($UMS_SIZE) to $UMS_FSTYPE"
		truncate -s $UMS_SIZE "$UMS_FILE"
		mkfs.$UMS_FSTYPE "$UMS_FILE" || \
			usb_msg "Failed to format $UMS_FILE to $UMS_FSTYPE"
	fi
}

ums_stop()
{
	echo > lun.0/file
	usb_umount "$UMS_MOUNTPOINT"

	[ "$UMS_MOUNT" -eq 1 ] || return 0

	# Try auto fstype firstly
	usb_mount "$UMS_FILE" "$UMS_MOUNTPOINT" -o sync 2>/dev/null || \
		usb_mount "$UMS_FILE" "$UMS_MOUNTPOINT" -o sync -t $UMS_FSTYPE
}

ums_start()
{
	case "$USB_STATE" in
		CONFIGURED)
			if [ "$(cat lun.0/ro)" != "$UMS_RO" ]; then
				echo > lun.0/file
				echo $UMS_RO > lun.0/ro
			fi

			if ! grep -wq "$UMS_FILE" lun.0/file; then
				usb_umount "$UMS_MOUNTPOINT"
				echo "$UMS_FILE" > lun.0/file
			fi
			;;
		DISCONNECTED)
			ums_stop
			;;
	esac
}

# ---- global
usb_init()
{
	usb_msg "Initializing"

	echo 0x2207 > idVendor
	echo 0x0310 > bcdDevice
	echo 0x0200 > bcdUSB

	mkdir -p $USB_GADGET_STRINGS_DIR
	SERIAL=$(grep Serial /proc/cpuinfo | cut -d':' -f2)
	echo ${SERIAL:-0123456789ABCDEF} > $USB_GADGET_STRINGS_DIR/serialnumber
	echo $USB_GROUP  > $USB_GADGET_STRINGS_DIR/manufacturer
	echo "rk3xxx"  > $USB_GADGET_STRINGS_DIR/product

	mkdir -p $USB_CONFIGS_DIR
	echo 500 > $USB_CONFIGS_DIR/MaxPower

	echo 0x1 > os_desc/b_vendor_code
	echo MSFT100 > os_desc/qw_sign
	ln -s $USB_CONFIGS_DIR os_desc/

	mkdir -p $USB_CONFIGS_STRINGS_DIR
}

usb_funcs_grep()
{
	echo $USB_FUNCS | xargs -n 1 | sort | uniq | grep $@ || true
}

usb_funcs_sort()
{
	{
		for func in $@; do
			usb_funcs_grep -E $func
		done
		usb_funcs_grep -vE $(echo $@ | tr ' ' '|')
	} | uniq | xargs
}

usb_prepare()
{
	usb_load_config

	# Allow function/variable overriding
	if [ -d /etc/usbdevice.d ]; then
		for hook in $(ls /etc/usbdevice.d/); do
			source "$hook"
		done
	fi

	UMS_FILE=${UMS_FILE:-/userdata/ums_shared.img}
	UMS_SIZE=${UMS_SIZE:-256M}
	UMS_FSTYPE=${UMS_FSTYPE:-vfat}
	UMS_MOUNT=${UMS_MOUNT:-0}
	UMS_MOUNTPOINT="${UMS_MOUNTPOINT:-/mnt/ums}"
	UMS_RO=${UMS_RO:-0}
	USB_FUNCS=${USB_FUNCS:-adb}

	# Orders required by kernel
	USB_FUNCS="$(usb_funcs_sort rndis uac uvc adb ntb ums mtp acm)"
	USB_CONFIG="$(echo "$USB_FUNCS" | tr ' ' '_')"

	if [ ! -d $USB_GADGET_DIR ]; then
		mountpoint -q $CONFIGFS_DIR || \
			mount -t configfs none $CONFIGFS_DIR

		mkdir -p $USB_GADGET_DIR
		cd $USB_GADGET_DIR

		# Global initialize
		usb_run_stage usb init
	fi

	USB_STATE=$(cat /sys/class/android_usb/android0/state)
	usb_msg "USB state: $USB_STATE"

	USB_UDC=$(ls /sys/class/udc/ | head -n 1)
	if [ -z "$USB_UDC" ]; then
		usb_msg "Failed to find a valid UDC device..."
		return 1
	fi

	usb_msg "Using USB UDC device: $USB_UDC"

	# Parse started USB functions
	OLD_FUNCS=$(usb_get_started)

	# Stop old USB functions when USB functions changed
	if [ -n "$OLD_FUNCS" ] && [ "$OLD_FUNCS" != "$USB_FUNCS" ]; then
		usb_msg "Functions changed $OLD_FUNCS -> $USB_FUNCS"
		usb_stop
	fi

	# Update USB PID
	usb_pid > $USB_GADGET_DIR/idProduct
}

usb_start()
{
	usb_msg "Starting functions: $USB_FUNCS"

	echo "$USB_CONFIG" > $USB_CONFIGS_STRINGS_DIR/configuration

	for func in $USB_FUNCS; do
		for instance in $(usb_instances $func); do
			usb_msg "Preparing instance: $instance"

			if ! mkdir -p $USB_FUNCTIONS_DIR/$instance \
				2>/dev/null; then
				usb_msg "Failed to create instance: $instance"
				continue
			fi

			cd $USB_FUNCTIONS_DIR/$instance \
				>/dev/null 2>/dev/null || continue

			usb_run_stage $func prepare

			# Make symlink after prepared (required by UVC)
			usb_symlink $USB_FUNCTIONS_DIR/$instance \
				$USB_CONFIGS_DIR/f-$instance
		done
	done

	usb_write $USB_GADGET_DIR/UDC $USB_UDC

	for func in $USB_FUNCS; do
		for instance in $(usb_instances $func); do
			cd $USB_FUNCTIONS_DIR/$instance \
				>/dev/null 2>/dev/null || continue

			usb_msg "Starting instance: $instance"
			usb_run_stage $func start
		done
	done

	# Store started functions
	usb_set_started
}

usb_stop()
{
	if [ -n "$OLD_FUNCS" ]; then
		usb_msg "Stopping functions: $OLD_FUNCS"
	fi

	usb_write $USB_GADGET_DIR/UDC ""

	for func in $USB_FUNCS; do
		for instance in $(usb_instances $func); do
			cd $USB_FUNCTIONS_DIR/$instance \
				>/dev/null 2>/dev/null || continue

			usb_msg "Stopping instance: $instance"
			usb_run_stage $func stop
		done
	done

	rm -f $USB_CONFIGS_DIR/f-*

	# Clear functions to avoid stopping them again
	unset OLD_FUNCS
}

usb_restart()
{
	usb_run_stage usb stop
	usb_run_stage usb start
}

ACTION=${1:-update}
if [ "$ACTION" = update ]; then
	usb_is_enabled || exit 0
fi

# Lock it
exec 3<$0
flock -x 3

if [ -z "$DEBUG" ]; then
	echo "Starting $0 ${ACTION}, log saved to $LOG_FILE"

	# Redirect outputs to log file
	exec >>$LOG_FILE 2>&1
fi

usb_msg "Handling ${ACTION} request"

usb_run_stage usb prepare

case "$ACTION" in
	start|update)
		usb_enable
		usb_run_stage usb start
		;;
	stop)
		usb_disable
		usb_run_stage usb stop
		;;
	restart)
		usb_enable
		usb_run_stage usb restart
		;;
	*)
		echo "Usage: usbdevice [start|stop|restart|update]" >&2
		;;
esac

usb_msg "Done $ACTION request"
echo

# Unlock it
flock -u 3

```

## external/uvc_app/uvc_config.sh

```sh

#!/bin/sh

USB_ROCKCHIP_DIR=/sys/kernel/config/usb_gadget/rockchip/
USB_FUNCTIONS_DIR=${USB_ROCKCHIP_DIR}/functions/
UVC_DIR=${USB_FUNCTIONS_DIR}/uvc.gs6/
UVC_STREAMING_DIR=${UVC_DIR}/streaming/
UVC_CONTROL_DIR=${UVC_DIR}/control/

UVC_U_DIR=${UVC_STREAMING_DIR}/uncompressed/u/
UVC_M_DIR=${UVC_STREAMING_DIR}/mjpeg/m/
UVC_F_DIR=${UVC_STREAMING_DIR}/framebased/f/

configure_uvc_resolution_yuyv()
{
	W=$1
	H=$2
	DIR=${UVC_U_DIR}/${H}p/
	mkdir ${DIR}
	echo $W > ${DIR}/wWidth
	echo $H > ${DIR}/wHeight
	echo 333333 > ${DIR}/dwDefaultFrameInterval
	echo $((W*H*20)) > ${DIR}/dwMinBitRate
	echo $((W*H*20)) > ${DIR}/dwMaxBitRate
	echo $((W*H*2)) > ${DIR}/dwMaxVideoFrameBufferSize
	echo -e "333333\n666666\n1000000\n2000000" > ${DIR}/dwFrameInterval
}

configure_uvc_resolution_mjpeg()
{
	W=$1
	H=$2
	DIR=${UVC_M_DIR}/${H}p/
	mkdir ${DIR}
	echo $W > ${DIR}/wWidth
	echo $H > ${DIR}/wHeight
	echo 333333 > ${DIR}/dwDefaultFrameInterval
	echo $((W*H*20)) > ${DIR}/dwMinBitRate
	echo $((W*H*20)) > ${DIR}/dwMaxBitRate
	echo $((W*H*2)) > ${DIR}/dwMaxVideoFrameBufferSize
	echo -e "333333\n666666\n1000000\n2000000" > ${DIR}/dwFrameInterval
}

configure_uvc_resolution_h264()
{
	W=$1
	H=$2
	DIR=${UVC_F_DIR}/${H}p/
	mkdir ${DIR}
	echo $W > ${DIR}/wWidth
	echo $H > ${DIR}/wHeight
	echo 333333 > ${DIR}/dwDefaultFrameInterval
	echo $((W*H*10)) > ${DIR}/dwMinBitRate
	echo $((W*H*10)) > ${DIR}/dwMaxBitRate
	#echo $((W*H*2)) > ${DIR}/dwMaxVideoFrameBufferSize
	echo -e "333333\n666666\n1000000\n2000000" > ${DIR}/dwFrameInterval
}

/etc/init.d/S10udev stop

umount /sys/kernel/config
mount -t configfs none /sys/kernel/config
mkdir -p ${USB_ROCKCHIP_DIR}
mkdir -p ${USB_ROCKCHIP_DIR}/strings/0x409
mkdir -p ${USB_ROCKCHIP_DIR}/configs/b.1/strings/0x409

echo 0x2207 > ${USB_ROCKCHIP_DIR}/idVendor
echo 0x0310 > ${USB_ROCKCHIP_DIR}/bcdDevice
echo 0x0200 > ${USB_ROCKCHIP_DIR}/bcdUSB

echo "2020" > ${USB_ROCKCHIP_DIR}/strings/0x409/serialnumber
echo "Rockchip" > ${USB_ROCKCHIP_DIR}/strings/0x409/manufacturer
echo "UVC" > ${USB_ROCKCHIP_DIR}/strings/0x409/product

mkdir ${UVC_DIR}
#echo 3072 > ${UVC_DIR}/streaming_maxpacket
#echo 1 > ${UVC_DIR}/streaming_bulk

mkdir ${UVC_CONTROL_DIR}/header/h
ln -s ${UVC_CONTROL_DIR}/header/h ${UVC_CONTROL_DIR}/class/fs/h
ln -s ${UVC_CONTROL_DIR}/header/h ${UVC_CONTROL_DIR}/class/ss/h

##YUYV support config
mkdir ${UVC_U_DIR}
configure_uvc_resolution_yuyv 640 480
configure_uvc_resolution_yuyv 1280 720

##mjpeg support config
mkdir ${UVC_M_DIR}
configure_uvc_resolution_mjpeg 640 480
configure_uvc_resolution_mjpeg 1280 720
configure_uvc_resolution_mjpeg 1920 1080
configure_uvc_resolution_mjpeg 2560 1440
configure_uvc_resolution_mjpeg 2592 1944

## h.264 support config
mkdir ${UVC_F_DIR}
configure_uvc_resolution_h264 640 480
configure_uvc_resolution_h264 1280 720
configure_uvc_resolution_h264 1920 1080

mkdir ${UVC_STREAMING_DIR}/header/h
ln -s ${UVC_U_DIR} ${UVC_STREAMING_DIR}/header/h/u
ln -s ${UVC_M_DIR} ${UVC_STREAMING_DIR}/header/h/m
ln -s ${UVC_F_DIR} ${UVC_STREAMING_DIR}/header/h/f
ln -s ${UVC_STREAMING_DIR}/header/h ${UVC_STREAMING_DIR}/class/fs/h
ln -s ${UVC_STREAMING_DIR}/header/h ${UVC_STREAMING_DIR}/class/hs/h
ln -s ${UVC_STREAMING_DIR}/header/h ${UVC_STREAMING_DIR}/class/ss/h

echo 0x1 > ${USB_ROCKCHIP_DIR}/os_desc/b_vendor_code
echo "MSFT100" > ${USB_ROCKCHIP_DIR}/os_desc/qw_sign
echo 500 > ${USB_ROCKCHIP_DIR}/configs/b.1/MaxPower
ln -s ${USB_ROCKCHIP_DIR}/configs/b.1 ${USB_ROCKCHIP_DIR}/os_desc/b.1

echo 0x0005 > ${USB_ROCKCHIP_DIR}/idProduct
echo "uvc" > ${USB_ROCKCHIP_DIR}/configs/b.1/strings/0x409/configuration
USB_CONFIGS_DIR=${USB_ROCKCHIP_DIR}/configs/b.1
if [ -e ${USB_CONFIGS_DIR}/ffs.adb ]; then
   #for rk1808 kernel 4.4
   rm -f ${USB_CONFIGS_DIR}/ffs.adb
else
   ls ${USB_CONFIGS_DIR} | grep f[0-9] | xargs -I {} rm ${USB_CONFIGS_DIR}/{}
fi
ln -s ${UVC_DIR} ${USB_ROCKCHIP_DIR}/configs/b.1/f1

UDC=`ls /sys/class/udc/| awk '{print $1}'`
echo $UDC > ${USB_ROCKCHIP_DIR}/UDC

```

## 打开工具

Ubuntu: guvcview

Windows: Amcap

Android: com.shenyaocn.android.usbdualcamera.apk

![guvcview](/images/hardware/camera/guvcview.png)

## Android

**默认生成的节点**

```bash

rk3568_r:/ $ ls /dev/video*
/dev/video0  /dev/video1

```

**dumpsys camera**

```bash

rk3568_r:/ $ dumpsys media.camera

== Service global info: ==

Number of camera devices: 1
Number of normal camera devices: 1
Number of public camera devices visible to API1: 1
    Device 0 maps to "100"
Active Camera Clients:
[]
Allowed user IDs: 0

== Camera service events log (most recent at top): ==
  05-24 16:12:15 : ADD device 100, reason: (Device added)
  05-24 16:11:52 : USER_SWITCH previous allowed user IDs: <None>, current allowed user IDs: 0

== Camera device 100 dynamic info: ==
  Device 100 is closed, no client instance
== Camera Provider HAL external/0 (v2.5, remote) static info: 1 devices: ==
== Camera HAL device device@3.4/external/100 (v3.4) static information: ==
  Resource cost: 100
  Conflicting devices: None
  API1 info:
    Has a flash unit: false
    Facing: Front
    Orientation: 0
  API2 camera characteristics:
    Dumping camera metadata array: 54 / 54 entries, 1800 / 1800 bytes of extra data.
      Version: 1, Flags: 00000000
      android.info.supportedHardwareLevel (150000): byte[1]
        [EXTERNAL ]
      android.colorCorrection.availableAberrationModes (00004): byte[1]
        [0 ]
      android.control.aeAvailableAntibandingModes (10012): byte[1]
        [3 ]
      android.control.maxRegions (1001c): int32[3]
        [0 0 0 ]
      android.control.availableVideoStabilizationModes (1001a): byte[1]
        [0 ]
      android.control.awbAvailableModes (1001b): byte[1]
        [1 ]
      android.control.aeAvailableModes (10013): byte[1]
        [1 ]
      android.control.availableEffects (10018): byte[1]
        [0 ]
      android.control.availableModes (10026): byte[2]
        [0 1 ]
      android.edge.availableEdgeModes (30002): byte[1]
        [0 ]
      android.flash.info.available (50000): byte[1]
        [FALSE ]
      android.hotPixel.availableHotPixelModes (60001): byte[1]
        [0 ]
      android.jpeg.availableThumbnailSizes (70007): int32[14]
        [0 0 176 144 ]
        [240 144 256 144 ]
        [240 160 256 154 ]
        [240 180 ]
      android.jpeg.maxSize (70008): int32[1]
        [3145728 ]
      android.lens.info.focusDistanceCalibration (90007): byte[1]
        [UNCALIBRATED ]
      android.lens.info.availableOpticalStabilization (90003): byte[1]
        [0 ]
      android.lens.facing (80005): byte[1]
        [EXTERNAL ]
      android.noiseReduction.availableNoiseReductionModes (a0002): byte[1]
        [0 ]
      android.noiseReduction.mode (a0000): byte[1]
        [OFF ]
      android.request.partialResultCount (c000b): int32[1]
        [1 ]
      android.request.pipelineMaxDepth (c000a): byte[1]
        [4 ]
      android.request.maxNumOutputStreams (c0006): int32[3]
        [0 2 1 ]
      android.request.maxNumInputStreams (c0008): int32[1]
        [0 ]
      android.scaler.availableMaxDigitalZoom (d0004): float[1]
        [1.00000000 ]
      android.scaler.croppingType (d000d): byte[1]
        [CENTER_ONLY ]
      android.sensor.availableTestPatternModes (e0019): int32[1]
        [0 ]
      android.sensor.info.timestampSource (f0008): byte[1]
        [UNKNOWN ]
      android.sensor.orientation (e000e): int32[1]
        [0 ]
      android.shading.availableModes (100002): byte[1]
        [0 ]
      android.statistics.info.availableFaceDetectModes (120000): byte[1]
        [0 ]
      android.statistics.info.maxFaceCount (120002): int32[1]
        [0 ]
      android.statistics.info.availableHotPixelMapModes (120006): byte[1]
        [0 ]
      android.statistics.info.availableLensShadingMapModes (120007): byte[1]
        [0 ]
      android.sync.maxLatency (170001): int32[1]
        [UNKNOWN ]
      android.request.availableRequestKeys (c000d): int32[28]
        [3 65536 65537 65538 ]
        [65539 65542 65541 65543 ]
        [65545 65546 65547 65549 ]
        [65550 65551 65552 65553 ]
        [262146 458755 458756 458757 ]
        [458758 524292 655360 851968 ]
        [917528 1114112 1114115 65583 ]
      android.request.availableResultKeys (c000e): int32[35]
        [3 65536 65537 65538 ]
        [65539 65542 65567 65541 ]
        [65543 65568 65545 65546 ]
        [65547 65570 65549 65550 ]
        [65551 65552 65553 262146 ]
        [262149 458755 458756 458757 ]
        [458758 524292 655360 786441 ]
        [851968 917520 1114112 1114115 ]
        [1114128 1114126 65583 ]
      android.request.availableCharacteristicsKeys (c000f): int32[43]
        [4 65554 65555 65556 ]
        [65557 65558 65572 65559 ]
        [65560 65574 65561 65562 ]
        [65563 65573 65564 327680 ]
        [1376256 458759 524293 589827 ]
        [589831 655362 786444 786440 ]
        [786438 786443 786442 851972 ]
        [851978 851981 983040 983044 ]
        [983046 983050 983048 917518 ]
        [1048578 1179648 1179654 1179655 ]
        [1179650 1507329 65582 ]
      android.control.aeCompensationRange (10015): int32[2]
        [0 0 ]
      android.control.aeCompensationStep (10016): rational[1]
        [(0 / 1) ]
      android.control.afAvailableModes (10017): byte[2]
        [1 0 ]
      android.control.availableSceneModes (10019): byte[1]
        [0 ]
      android.control.aeLockAvailable (10024): byte[1]
        [FALSE ]
      android.control.awbLockAvailable (10025): byte[1]
        [FALSE ]
      android.scaler.availableStreamConfigurations (d000a): int32[60]
        [33 640 480 OUTPUT ]
        [35 640 480 OUTPUT ]
        [34 640 480 OUTPUT ]
        [33 1280 720 OUTPUT ]
        [35 1280 720 OUTPUT ]
        [34 1280 720 OUTPUT ]
        [33 1920 1080 OUTPUT ]
        [35 1920 1080 OUTPUT ]
        [34 1920 1080 OUTPUT ]
        [33 2560 1440 OUTPUT ]
        [35 2560 1440 OUTPUT ]
        [34 2560 1440 OUTPUT ]
        [33 2592 1944 OUTPUT ]
        [35 2592 1944 OUTPUT ]
        [34 2592 1944 OUTPUT ]
      android.scaler.availableMinFrameDurations (d000b): int64[60]
        [33 640 ]
        [480 200000000 ]
        [35 640 ]
        [480 200000000 ]
        [34 640 ]
        [480 200000000 ]
        [33 1280 ]
        [720 200000000 ]
        [35 1280 ]
        [720 200000000 ]
        [34 1280 ]
        [720 200000000 ]
        [33 1920 ]
        [1080 200000000 ]
        [35 1920 ]
        [1080 200000000 ]
        [34 1920 ]
        [1080 200000000 ]
        [33 2560 ]
        [1440 200000000 ]
        [35 2560 ]
        [1440 200000000 ]
        [34 2560 ]
        [1440 200000000 ]
        [33 2592 ]
        [1944 200000000 ]
        [35 2592 ]
        [1944 200000000 ]
        [34 2592 ]
        [1944 200000000 ]
      android.scaler.availableStallDurations (d000c): int64[60]
        [33 640 ]
        [480 1000000000 ]
        [35 640 ]
        [480 0 ]
        [34 640 ]
        [480 0 ]
        [33 1280 ]
        [720 1000000000 ]
        [35 1280 ]
        [720 0 ]
        [34 1280 ]
        [720 0 ]
        [33 1920 ]
        [1080 1000000000 ]
        [35 1920 ]
        [1080 0 ]
        [34 1920 ]
        [1080 0 ]
        [33 2560 ]
        [1440 1000000000 ]
        [35 2560 ]
        [1440 0 ]
        [34 2560 ]
        [1440 0 ]
        [33 2592 ]
        [1944 1000000000 ]
        [35 2592 ]
        [1944 0 ]
        [34 2592 ]
        [1944 0 ]
      android.control.aeAvailableTargetFpsRanges (10014): int32[2]
        [2 5 ]
      android.sensor.info.maxFrameDuration (f0004): int64[1]
        [500000000 ]
      android.sensor.info.preCorrectionActiveArraySize (f000a): int32[4]
        [0 0 2592 1944 ]
      android.sensor.info.activeArraySize (f0000): int32[4]
        [0 0 2592 1944 ]
      android.sensor.info.pixelArraySize (f0006): int32[2]
        [2592 1944 ]
      android.request.availableCapabilities (c000c): byte[1]
        [BACKWARD_COMPATIBLE ]
      android.scaler.availableRotateAndCropModes (d0010): byte[1]
        [0 ]
      android.control.zoomRatioRange (1002e): float[2]
        [1.00000000 1.00000000 ]
== Camera HAL device device@3.4/external/100 (v3.4) dumpState: ==
No active camera device session instance
== Camera Provider HAL legacy/0 (v2.5, remote) static info: 0 devices: ==

== Vendor tags: ==

  Dumping vendor tag descriptors for vendor with id 3854507339 
  Dumping configured vendor tag descriptors: 10 entries
    0x80000000 (privatedata_effective_driver_frame_id) with type 3 (int64) defined in section org.codeaurora.rkcamera3.privatedata
    0x80000001 (privatedata_frame_sof_timestamp) with type 3 (int64) defined in section org.codeaurora.rkcamera3.privatedata
    0x80000002 (privatedata_stillcap_sync_needed) with type 0 (byte) defined in section org.codeaurora.rkcamera3.privatedata
    0x80000003 (privatedata_stillcap_sync_cmd) with type 0 (byte) defined in section org.codeaurora.rkcamera3.privatedata
    0x80000004 (privatedata_stillcap_isp_param) with type 0 (byte) defined in section org.codeaurora.rkcamera3.privatedata
    0x80010000 (3dnrmode) with type 0 (byte) defined in section com.rockchip.nrfeature
    0x80020000 (brightness) with type 0 (byte) defined in section com.rockchip.control.aiq
    0x80020001 (contrast) with type 0 (byte) defined in section com.rockchip.control.aiq
    0x80020002 (saturation) with type 0 (byte) defined in section com.rockchip.control.aiq
    0x80030000 (meanluma) with type 2 (float) defined in section com.rockchip.luma
  Dumping vendor tag descriptors for vendor with id 2592128789 
  Dumping configured vendor tag descriptors: None set

== Camera error traces (0): ==
  No camera traces collected.


```

**安卓系统打开相机时的注意事项**

`S50usbdevice.sh` 文件中的分辨率需要在 `uvc_config.sh`文件中包含

安卓app打开相机时选择的分辨率需要和 `S50usbdevice.sh` 文件中配置的一致




















